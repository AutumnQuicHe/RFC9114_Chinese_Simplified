---
title: "4.6. 服务器推送"
anchor: "4.6_Server_Push"
weight: 40600
rank: "h2"
---

服务器推送是一种交互模式，它允许服务器在预料到客户端会发送某个请求时向客户端主动推送一次请求与响应的通信。
这会增加网络负载，但是有可能在延迟表现上得到提升。
HTTP/3的服务器推送与《[HTTP/2](https://www.rfc-editor.org/info/rfc9113)》的[第8.2章](https://www.rfc-editor.org/rfc/rfc9113#section-8.2)中的描述十分相似，但是它使用的是不同的机制。

服务器为每一次推送分配唯一的推送ID。
在一条HTTP/3连接的生命周期中，始终可以使用推送ID来作为对此推送的引用。

推送ID的编号空间从零开始，不超过由**最大推送ID帧**设置的最大值。
注意，服务器只有在客户端发送了**最大推送ID帧**之后才能进行推送。
客户端使用**最大推送ID帧**来控制服务器可以承诺的推送数量。
服务器{{< req_level SHOULD >}}从零开始按次序使用推送ID。
如果客户端在尚未发送出**最大推送ID帧**时就接收到了推送流，或者该流引用了一个超过最大推送ID的推送ID，那么{{< req_level MUST >}}将该情况视作类型为`H3_ID_ERROR`（ID错误）的连接错误。

同一个推送ID可以在一个或多个**推送承诺帧**中被使用，后者传递的是请求消息的控制数据和标头字段。
这些帧是在创建了推送的请求流上被发送的。
这使得服务器推送能够被关联到某个客户端请求上。
当多条请求流中承诺了相同的推送ID时，经解压缩的请求字段组中{{< req_level MUST >}}包含相同字段，这些字段{{< req_level MUST >}}出现顺序相同、名称一致，并且值也完全一致。

随后，这个推送ID会出现在最终兑现了那些承诺的推送流中。
推送流会以它兑现的承诺的推送ID为标识，并且包含着对被承诺的请求的响应，详见[第4.1章](#4.1_HTTP_Message_Framing)。

最后，推送ID可以被用于**取消推送帧**中；详见[第7.2.3章](#7.2.3_CANCEL_PUSH)。
客户端使用这种帧来表明它们不想要接收到被承诺的资源。
服务器使用这种帧来表明它们将不会兑现先前的承诺。

并不是所有的请求都是可以被推送的。
服务器{{< req_level MAY >}}推送具有以下属性的请求：

* 可缓存的；详见《[HTTP](https://www.rfc-editor.org/info/rfc9110)》的[第9.2.3章](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.3)

* 安全的；详见《[HTTP](https://www.rfc-editor.org/info/rfc9110)》的[第9.2.1章](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1)

* 不包含请求内容和挂载

服务器{{< req_level MUST >}}为伪标头字段`:authority`设置一个值，并且服务器对该值具有权威。
如果客户端尚未验证过与被推送的请求的源之间的连接，那么它{{< req_level MUST >}}宛如第一次向该源发送请求时一般对源进行验证；详见[第3.3章](#3.3_Connection_Reuse)。
如果验证失败，那么客户端{{< req_level MUST_NOT >}}认为该服务器对此源具有权威。

如果客户端接收到的**推送请求帧**所携带的请求无法缓存、已知为不安全、存在请求内容或它不认为该服务器具有权威，那么它{{< req_level SHOULD >}}发送**取消推送帧**。
同时，任何与此相关的响应都{{< req_level MUST_NOT >}}被使用或被缓存。

每份被推送的响应都被关联到一个或多个客户端请求上。
每份推送都可以被关联到接收到了**推送承诺帧**的请求流上。
此外，同一份服务器推送还可以被关联到其他请求流的客户端请求上，只要这些请求使用的**推送承诺帧**也使用了相同的推送ID。
这些关联并不会破坏协议，但是用户代理在决定如何使用被推送的资源时{{< req_level MAY >}}将它们纳入考量。

**推送承诺帧**与响应的某些部分之间的顺序很重要。
服务器{{< req_level SHOULD >}}先在发送**推送承诺帧**，再发送引用了将被推送的响应的**标头帧**或**数据帧**。
这能降低客户端为一项将会由服务器推送的资源发出请求的可能性。

由于数据包乱序的存在，推送流的数据可能先于相应的**推送承诺帧**抵达客户端。
当客户端接收到了一条新的推送流且从未见过它的推送ID时，与其关联的客户端请求和被推送的请求标头字段还都是未知的。
客户端可以将流数据缓存下来，并期待与之匹配的**推送承诺帧**。
客户端能够使用流量控制机制（详见《[QUIC传输](../RFC9000_Chinese_Simplified)》的[第4.1章](../RFC9000_Chinese_Simplified/#4.1_Data_Flow_Control)）来限制服务器可以使用在推送流上的数据量。
如果经过一段合理的时间后，仍然没有处理到相应的**推送承诺帧**，那么客户端{{< req_level SHOULD >}}中止读取该推送流，并且丢弃所有已经从中读取的数据。

推送流的数据也可能在客户端已经取消某次推送后才抵达。
在这种情况下，客户端可以使用错误码`H3_REQUEST_CANCELLED`来中止对流的读取。
这么做要求服务器不要继续传输数据，并表明剩余数据会在接收时被丢弃。

如果客户端实现了HTTP缓存，那么可以将被推送的响应中的可缓存的那些（详见《[HTTP-CACHING](https://www.rfc-editor.org/info/rfc9111)》的[第3章](https://www.rfc-editor.org/rfc/rfc9111#section-3)）给存储起来。
在接收被推送的响应的那一刻，就可以认为它们是成功经过了源服务器的认证的（就好像存在缓存响应指令`no-cache`一样；详见《[HTTP-CACHING](https://www.rfc-editor.org/info/rfc9111)》的[第5.2.2.4章](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.4)）。

被推送的响应中的不可缓存的那些{{< req_level MUST_NOT >}}被任何HTTP缓存所存储。
它们{{< req_level MAY >}}被单独交给应用。
